// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CREATURE_EVOLVINGCREATURE_H_
#define FLATBUFFERS_GENERATED_CREATURE_EVOLVINGCREATURE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

namespace EvolvingCreature {

struct Vec3;

struct CreaturePart;
struct CreaturePartBuilder;

struct Creature;
struct CreatureBuilder;

enum ArticulationAxis : int8_t {
  ArticulationAxis_eTWIST = 0,
  ArticulationAxis_eSWING1 = 1,
  ArticulationAxis_eSWING2 = 2,
  ArticulationAxis_MIN = ArticulationAxis_eTWIST,
  ArticulationAxis_MAX = ArticulationAxis_eSWING2
};

inline const ArticulationAxis (&EnumValuesArticulationAxis())[3] {
  static const ArticulationAxis values[] = {
    ArticulationAxis_eTWIST,
    ArticulationAxis_eSWING1,
    ArticulationAxis_eSWING2
  };
  return values;
}

inline const char * const *EnumNamesArticulationAxis() {
  static const char * const names[4] = {
    "eTWIST",
    "eSWING1",
    "eSWING2",
    nullptr
  };
  return names;
}

inline const char *EnumNameArticulationAxis(ArticulationAxis e) {
  if (::flatbuffers::IsOutRange(e, ArticulationAxis_eTWIST, ArticulationAxis_eSWING2)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesArticulationAxis()[index];
}

enum ArticulationMotion : int8_t {
  ArticulationMotion_eLOCKED = 0,
  ArticulationMotion_eLIMITED = 1,
  ArticulationMotion_eFREE = 2,
  ArticulationMotion_MIN = ArticulationMotion_eLOCKED,
  ArticulationMotion_MAX = ArticulationMotion_eFREE
};

inline const ArticulationMotion (&EnumValuesArticulationMotion())[3] {
  static const ArticulationMotion values[] = {
    ArticulationMotion_eLOCKED,
    ArticulationMotion_eLIMITED,
    ArticulationMotion_eFREE
  };
  return values;
}

inline const char * const *EnumNamesArticulationMotion() {
  static const char * const names[4] = {
    "eLOCKED",
    "eLIMITED",
    "eFREE",
    nullptr
  };
  return names;
}

inline const char *EnumNameArticulationMotion(ArticulationMotion e) {
  if (::flatbuffers::IsOutRange(e, ArticulationMotion_eLOCKED, ArticulationMotion_eFREE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesArticulationMotion()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3(float _x, float _y, float _z)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);

struct CreaturePart FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CreaturePartBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALE = 4,
    VT_RELATIVE_POSITION = 6,
    VT_JOINT_POSITION = 8,
    VT_MAX_JOINT_VEL = 10,
    VT_JOINT_OSCILLATION_SPEED = 12,
    VT_JOINT_AXIS = 14,
    VT_JOINT_MOTION = 16,
    VT_JOINT_LOW_LIMIT = 18,
    VT_JOINT_HIGH_LIMIT = 20,
    VT_JOINT_DRIVE_STIFFNESS = 22,
    VT_JOINT_DRIVE_DAMPING = 24,
    VT_JOINT_DRIVE_MAX_FORCE = 26,
    VT_CHILDREN = 28
  };
  const EvolvingCreature::Vec3 *scale() const {
    return GetStruct<const EvolvingCreature::Vec3 *>(VT_SCALE);
  }
  const EvolvingCreature::Vec3 *relative_position() const {
    return GetStruct<const EvolvingCreature::Vec3 *>(VT_RELATIVE_POSITION);
  }
  const EvolvingCreature::Vec3 *joint_position() const {
    return GetStruct<const EvolvingCreature::Vec3 *>(VT_JOINT_POSITION);
  }
  float max_joint_vel() const {
    return GetField<float>(VT_MAX_JOINT_VEL, 0.0f);
  }
  float joint_oscillation_speed() const {
    return GetField<float>(VT_JOINT_OSCILLATION_SPEED, 0.0f);
  }
  EvolvingCreature::ArticulationAxis joint_axis() const {
    return static_cast<EvolvingCreature::ArticulationAxis>(GetField<int8_t>(VT_JOINT_AXIS, 0));
  }
  EvolvingCreature::ArticulationMotion joint_motion() const {
    return static_cast<EvolvingCreature::ArticulationMotion>(GetField<int8_t>(VT_JOINT_MOTION, 0));
  }
  float joint_low_limit() const {
    return GetField<float>(VT_JOINT_LOW_LIMIT, 0.0f);
  }
  float joint_high_limit() const {
    return GetField<float>(VT_JOINT_HIGH_LIMIT, 0.0f);
  }
  float joint_drive_stiffness() const {
    return GetField<float>(VT_JOINT_DRIVE_STIFFNESS, 0.0f);
  }
  float joint_drive_damping() const {
    return GetField<float>(VT_JOINT_DRIVE_DAMPING, 0.0f);
  }
  float joint_drive_max_force() const {
    return GetField<float>(VT_JOINT_DRIVE_MAX_FORCE, 0.0f);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<EvolvingCreature::CreaturePart>> *children() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<EvolvingCreature::CreaturePart>> *>(VT_CHILDREN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<EvolvingCreature::Vec3>(verifier, VT_SCALE, 4) &&
           VerifyField<EvolvingCreature::Vec3>(verifier, VT_RELATIVE_POSITION, 4) &&
           VerifyField<EvolvingCreature::Vec3>(verifier, VT_JOINT_POSITION, 4) &&
           VerifyField<float>(verifier, VT_MAX_JOINT_VEL, 4) &&
           VerifyField<float>(verifier, VT_JOINT_OSCILLATION_SPEED, 4) &&
           VerifyField<int8_t>(verifier, VT_JOINT_AXIS, 1) &&
           VerifyField<int8_t>(verifier, VT_JOINT_MOTION, 1) &&
           VerifyField<float>(verifier, VT_JOINT_LOW_LIMIT, 4) &&
           VerifyField<float>(verifier, VT_JOINT_HIGH_LIMIT, 4) &&
           VerifyField<float>(verifier, VT_JOINT_DRIVE_STIFFNESS, 4) &&
           VerifyField<float>(verifier, VT_JOINT_DRIVE_DAMPING, 4) &&
           VerifyField<float>(verifier, VT_JOINT_DRIVE_MAX_FORCE, 4) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.VerifyVector(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           verifier.EndTable();
  }
};

struct CreaturePartBuilder {
  typedef CreaturePart Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_scale(const EvolvingCreature::Vec3 *scale) {
    fbb_.AddStruct(CreaturePart::VT_SCALE, scale);
  }
  void add_relative_position(const EvolvingCreature::Vec3 *relative_position) {
    fbb_.AddStruct(CreaturePart::VT_RELATIVE_POSITION, relative_position);
  }
  void add_joint_position(const EvolvingCreature::Vec3 *joint_position) {
    fbb_.AddStruct(CreaturePart::VT_JOINT_POSITION, joint_position);
  }
  void add_max_joint_vel(float max_joint_vel) {
    fbb_.AddElement<float>(CreaturePart::VT_MAX_JOINT_VEL, max_joint_vel, 0.0f);
  }
  void add_joint_oscillation_speed(float joint_oscillation_speed) {
    fbb_.AddElement<float>(CreaturePart::VT_JOINT_OSCILLATION_SPEED, joint_oscillation_speed, 0.0f);
  }
  void add_joint_axis(EvolvingCreature::ArticulationAxis joint_axis) {
    fbb_.AddElement<int8_t>(CreaturePart::VT_JOINT_AXIS, static_cast<int8_t>(joint_axis), 0);
  }
  void add_joint_motion(EvolvingCreature::ArticulationMotion joint_motion) {
    fbb_.AddElement<int8_t>(CreaturePart::VT_JOINT_MOTION, static_cast<int8_t>(joint_motion), 0);
  }
  void add_joint_low_limit(float joint_low_limit) {
    fbb_.AddElement<float>(CreaturePart::VT_JOINT_LOW_LIMIT, joint_low_limit, 0.0f);
  }
  void add_joint_high_limit(float joint_high_limit) {
    fbb_.AddElement<float>(CreaturePart::VT_JOINT_HIGH_LIMIT, joint_high_limit, 0.0f);
  }
  void add_joint_drive_stiffness(float joint_drive_stiffness) {
    fbb_.AddElement<float>(CreaturePart::VT_JOINT_DRIVE_STIFFNESS, joint_drive_stiffness, 0.0f);
  }
  void add_joint_drive_damping(float joint_drive_damping) {
    fbb_.AddElement<float>(CreaturePart::VT_JOINT_DRIVE_DAMPING, joint_drive_damping, 0.0f);
  }
  void add_joint_drive_max_force(float joint_drive_max_force) {
    fbb_.AddElement<float>(CreaturePart::VT_JOINT_DRIVE_MAX_FORCE, joint_drive_max_force, 0.0f);
  }
  void add_children(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EvolvingCreature::CreaturePart>>> children) {
    fbb_.AddOffset(CreaturePart::VT_CHILDREN, children);
  }
  explicit CreaturePartBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CreaturePart> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CreaturePart>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CreaturePart> CreateCreaturePart(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const EvolvingCreature::Vec3 *scale = nullptr,
    const EvolvingCreature::Vec3 *relative_position = nullptr,
    const EvolvingCreature::Vec3 *joint_position = nullptr,
    float max_joint_vel = 0.0f,
    float joint_oscillation_speed = 0.0f,
    EvolvingCreature::ArticulationAxis joint_axis = EvolvingCreature::ArticulationAxis_eTWIST,
    EvolvingCreature::ArticulationMotion joint_motion = EvolvingCreature::ArticulationMotion_eLOCKED,
    float joint_low_limit = 0.0f,
    float joint_high_limit = 0.0f,
    float joint_drive_stiffness = 0.0f,
    float joint_drive_damping = 0.0f,
    float joint_drive_max_force = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<EvolvingCreature::CreaturePart>>> children = 0) {
  CreaturePartBuilder builder_(_fbb);
  builder_.add_children(children);
  builder_.add_joint_drive_max_force(joint_drive_max_force);
  builder_.add_joint_drive_damping(joint_drive_damping);
  builder_.add_joint_drive_stiffness(joint_drive_stiffness);
  builder_.add_joint_high_limit(joint_high_limit);
  builder_.add_joint_low_limit(joint_low_limit);
  builder_.add_joint_oscillation_speed(joint_oscillation_speed);
  builder_.add_max_joint_vel(max_joint_vel);
  builder_.add_joint_position(joint_position);
  builder_.add_relative_position(relative_position);
  builder_.add_scale(scale);
  builder_.add_joint_motion(joint_motion);
  builder_.add_joint_axis(joint_axis);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CreaturePart> CreateCreaturePartDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const EvolvingCreature::Vec3 *scale = nullptr,
    const EvolvingCreature::Vec3 *relative_position = nullptr,
    const EvolvingCreature::Vec3 *joint_position = nullptr,
    float max_joint_vel = 0.0f,
    float joint_oscillation_speed = 0.0f,
    EvolvingCreature::ArticulationAxis joint_axis = EvolvingCreature::ArticulationAxis_eTWIST,
    EvolvingCreature::ArticulationMotion joint_motion = EvolvingCreature::ArticulationMotion_eLOCKED,
    float joint_low_limit = 0.0f,
    float joint_high_limit = 0.0f,
    float joint_drive_stiffness = 0.0f,
    float joint_drive_damping = 0.0f,
    float joint_drive_max_force = 0.0f,
    const std::vector<::flatbuffers::Offset<EvolvingCreature::CreaturePart>> *children = nullptr) {
  auto children__ = children ? _fbb.CreateVector<::flatbuffers::Offset<EvolvingCreature::CreaturePart>>(*children) : 0;
  return EvolvingCreature::CreateCreaturePart(
      _fbb,
      scale,
      relative_position,
      joint_position,
      max_joint_vel,
      joint_oscillation_speed,
      joint_axis,
      joint_motion,
      joint_low_limit,
      joint_high_limit,
      joint_drive_stiffness,
      joint_drive_damping,
      joint_drive_max_force,
      children__);
}

struct Creature FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CreatureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROOT_PART = 4
  };
  const EvolvingCreature::CreaturePart *root_part() const {
    return GetPointer<const EvolvingCreature::CreaturePart *>(VT_ROOT_PART);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROOT_PART) &&
           verifier.VerifyTable(root_part()) &&
           verifier.EndTable();
  }
};

struct CreatureBuilder {
  typedef Creature Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_root_part(::flatbuffers::Offset<EvolvingCreature::CreaturePart> root_part) {
    fbb_.AddOffset(Creature::VT_ROOT_PART, root_part);
  }
  explicit CreatureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Creature> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Creature>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Creature> CreateCreature(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<EvolvingCreature::CreaturePart> root_part = 0) {
  CreatureBuilder builder_(_fbb);
  builder_.add_root_part(root_part);
  return builder_.Finish();
}

inline const EvolvingCreature::Creature *GetCreature(const void *buf) {
  return ::flatbuffers::GetRoot<EvolvingCreature::Creature>(buf);
}

inline const EvolvingCreature::Creature *GetSizePrefixedCreature(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<EvolvingCreature::Creature>(buf);
}

inline bool VerifyCreatureBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<EvolvingCreature::Creature>(nullptr);
}

inline bool VerifySizePrefixedCreatureBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<EvolvingCreature::Creature>(nullptr);
}

inline void FinishCreatureBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<EvolvingCreature::Creature> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCreatureBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<EvolvingCreature::Creature> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace EvolvingCreature

#endif  // FLATBUFFERS_GENERATED_CREATURE_EVOLVINGCREATURE_H_
